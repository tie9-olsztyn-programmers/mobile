[//]: # (---)

[//]: # (title: Jetpack Compose)

[//]: # (---)

[//]: # ()
[//]: # (# Co to jest Jetpack Compose?)

[//]: # (- to fundament, na którym budujesz interfejs aplikacji Android w sposób deklaratywny i reaktywny.)

[//]: # (- Zamiast ręcznie tworzyć i manipulować View-ami w XML,)

[//]: # (- piszesz w Kotlinie zestaw funkcji `@Composable`, które w czasie działania aplikacji „emitują” &#40;czyli przekazują do frameworka&#41; kolejne węzły interfejsu.)

[//]: # (- To właśnie te wywołania są następnie wizualizowane na ekranie jako widoki użytkownika.)

[//]: # (- *Compose* automatycznie śledzi, co się zmienia w stanie i odświeża jedynie te części UI, które tego wymagają — to znacznie upraszcza i przyspiesza rozwój nowoczesnych aplikacji mobilnych.)

[//]: # ()
[//]: # (https://developer.android.com/compose)

[//]: # ()
[//]: # ()
[//]: # (# Cechy systemu Jetpack Compose:)

[//]: # ()
[//]: # (- Deklaratywność)

[//]: # (    - W tradycyjnym podejściu &#40;View + XML&#41; najpierw tworzysz widoki &#40;np. `TextView`, `Button`&#41; w XML, a w Activity czy Fragment ręcznie odwołujesz się do nich, manipulujesz ich stanem i widocznością.)

[//]: # (    - W *Compose* natomiast piszesz funkcję, która w danym momencie zwraca „opis” tego, co ma się znaleźć na ekranie—biorąc pod uwagę aktualny stan aplikacji.)

[//]: # (      Jeżeli stan się zmieni, *Compose ponownie wywoła tę funkcję, zaktualizując widoczne elementy automatycznie &#40;to proces zwany *recomposition*&#41;.)

[//]: # ()
[//]: # (- Brak XML-a, wszystko w Kotlinie)

[//]: # (    - ` UI opisujesz jako zestaw zagnieżdżonych funkcji `@Composable`, np. `Column { Text&#40;"Cześć"&#41; }`  zamiast `<LinearLayout> <TextView …/> </LinearLayout>` w XML.)

[//]: # (    - Dzięki temu masz pełnię możliwości języka Kotlin &#40;ekstensje, typy, lambdy itp.&#41; podczas konstrukcji UI.)

[//]: # (- Reaktywne aktualizacje &#40;*Recomposition*&#41;)

[//]: # (    - Każdy *composable* może odczytywać fragment stanu &#40;np. wartość z `StateFlow`, `MutableState` lub parametru funkcji&#41;.)

[//]: # (    - Gdy ten stan się zmienia, *Compose* wykrywa potrzebę odświeżenia UI i automatycznie „rekomponuje” tylko te fragmenty, które uległy zmianie.)

[//]: # (    - To upraszcza zarządzanie widokami: nie musisz ręcznie wyszukiwać kontrolki i ustawiać jej tekstu czy widoczności.)

[//]: # (- Kompozycja zamiast hierarchii widoków)

[//]: # (    - Przy klasycznym `ViewGroup` mamy drzewo widoków widoczne w hierarchii: `LinearLayout` → `TextView` → `Button` itd.)

[//]: # (    - W Compose też budujesz drzewo, ale nie w XML, tylko w kodzie Kotlinowym.)

[//]: # (    - *Compose* pod spodem tworzy własne reprezentacje tych węzłów i renderuje je optymalnie na ekranie &#40;z uwzględnieniem np. zagnieżdżonych "Modifierów"&#41;.)

[//]: # (- Modularność – *composable* jako jednostki UI)

[//]: # (    - Każdą część interfejsu opisujesz jako oddzielną funkcję `@Composable`, która przyjmuje parametry &#40;np. tekst, stan, handler kliknięcia&#41; oraz opcjonalny `Modifier`.)

[//]: # (    - Te funkcje możesz ze sobą komponować &#40;ewentualnie przekazywać między nimi dane&#41;, co sprzyja utrzymaniu porządku i ponownemu użyciu elementów UI.)

[//]: # (- *Modiﬁers* &#40;modyfikatory&#41;)

[//]: # (    - Zamiast atrybutów XML &#40;np. `android:layout_margin="16dp"`, `android:background="@color/primary"`&#41; używasz obiektów *Modifier* w *Compose*)

[//]: # (    – łańcuchowo łączysz różne funkcje &#40;np. `Modifier.padding&#40;16.dp&#41;.fillMaxWidth&#40;&#41;.background&#40;Color.Red&#41;`&#41;.)

[//]: # (    - To jeden spójny mechanizm określania położenia, wymiarów, gestów, cieni, tła itp.)

[//]: # (- Intuicyjne narzędzia deweloperskie)

[//]: # (    - Dzięki adnotacji `@Preview` możesz w Android Studio podglądać wycinki UI bez uruchamiania emulowanej aplikacji.)

[//]: # (    - *Compose* oferuje także zaawansowane narzędzia profilujące i wizualizujące drzewo *composable* w czasie rzeczywistym &#40;*Layout Inspector*, *Compose Preview*&#41;.)

[//]: # (- Wbudowana integracja z Material Design)

[//]: # (    - Biblioteki *Compose Material* i *Compose Material3* dostarczają gotowe komponowalne implementacje elementów zgodnych z *Material Design*:)

[//]: # (        - przyciski,)

[//]: # (        - karty,)

[//]: # (        - pola tekstowe,)

[//]: # (        - motywy kolorystyczne,)

[//]: # (        - itd.)

[//]: # (    - Wystarczy użyć `MaterialTheme&#40;...&#41; { … }` w swoim kodzie, aby mieć automatycznie ustawione kolory, typografię i zachowania zgodne ze standardem *Material*.)

[//]: # (- Wydajność i mniejsze narzuty)

[//]: # (    - Ponieważ *Compose* buduje i optymalizuje drzewo elementów dynamicznie w Kotlinie, a sam proces rekompozycji jest ograniczony do tych fragmentów, które faktycznie się zmieniły,)

[//]: # (      aplikacje bywają bardziej responsywne.)

[//]: # (    - Usunięcie XML-owej warstwy pośredniej &#40;inflation&#41; redukuje nadmiarowy kod i poprawia czas startu ekranów.)

[//]: # (- Ekosystem *Jetpack*)

[//]: # (    - *Compose* jest częścią *Android Jetpack* &#40;czyli zestawu nowoczesnych bibliotek Google&#41;.)

[//]: # (    - Współpracuje bezproblemowo z innymi bibliotekami &#40;Navigation Compose do nawigacji, Hilt Compose do wstrzykiwania zależności, Lifecycle + ViewModel + StateFlow itp.&#41;.)

[//]: # (    - Dzięki temu proponowane przez Google „wzorce architektoniczne” &#40;MVVM, jednokierunkowy przepływ danych&#41; są proste we wdrożeniu.)

[//]: # ()
[//]: # ()
[//]: # ()
[//]: # ()
[//]: # ()
[//]: # ()
[//]: # (# Pierwszy projekt)

[//]: # (### Android Studio: Nowy projekt > Empty Activity)

[//]: # (```kotlin)

[//]: # (class MainActivity : ComponentActivity&#40;&#41; {)

[//]: # (    override fun onCreate&#40;savedInstanceState: Bundle?&#41; {)

[//]: # (        super.onCreate&#40;savedInstanceState&#41;)

[//]: # (        enableEdgeToEdge&#40;&#41;)

[//]: # (        setContent {)

[//]: # (            FirstJetPackTheme {)

[//]: # (                Scaffold&#40;modifier = Modifier.fillMaxSize&#40;&#41;&#41; { innerPadding ->)

[//]: # (                    Greeting&#40;)

[//]: # (                        name = "Android",)

[//]: # (                        modifier = Modifier.padding&#40;innerPadding&#41;)

[//]: # (                    &#41;)

[//]: # (                })

[//]: # (            })

[//]: # (        })

[//]: # (    })

[//]: # (})

[//]: # (```)

[//]: # ()
[//]: # (- `MainActivity : ComponentActivity&#40;&#41;`)

[//]: # (    - dziedziczenie po `ComponentActivity`, która pochodzi z biblioteki *AndroidX* i jest „lekko-wagową” bazą pod Composable-owe &#40;jetpack-compose’owe&#41; UI.)

[//]: # (    - Dzięki `ComponentActivity` otrzymujemy prostą integrację z Compose &#40;m.in. możliwość wywołania `setContent { … }`&#41;.)

[//]: # ()
[//]: # (- `override fun onCreate&#40;savedInstanceState: Bundle?&#41; { ... }`)

[//]: # (    - Standardowa metoda cyklu życia aktywności Androida.)

[//]: # (    - Najpierw wywołujemy `super.onCreate&#40;savedInstanceState&#41;`, aby poprawnie zainicjować działanie `ComponentActivity`.)

[//]: # (    - `enableEdgeToEdge&#40;&#41;`)

[//]: # (        - która konfiguruje okno aplikacji tak, by "rysować" UI „od krawędzi do krawędzi” ekranu.)

[//]: # (        - W praktyce oznacza to:)

[//]: # (            - Dezaktywację domyślnego zachowania „wypełniania” przestrzeni pod pasek statusu i nawigacyjny.)

[//]: # (            - Dopuszczenie rysowania treści aplikacji za pasek statusu &#40;status bar&#41; i pasek nawigacji &#40;navigation bar&#41;, co umożliwia efekt tzw. edge-to-edge.)

[//]: # (- `setContent { … }` To punkt wejścia do composable’owego UI.)

[//]: # (    - Zamiast setContentView&#40;R.layout.activity_main&#41; &#40;jak w XML-owym podejściu&#41;, tutaj wstawiasz w lambda-blok kod Compose, który buduje cały interfejs.)

[//]: # (    - Wszystko, co znajduje się wewnątrz klamerek `setContent { … }`, to tzw. composable’owe elementy UI, składające się hierarchicznie.)

[//]: # ()
[//]: # (- `FirstJetPackTheme { … }`)

[//]: # (    - To *wrapper* &#40;tzw. `@Composable`&#41; automatycznie wygenerowanyprzez template Android Studio.)

[//]: # (    - Zawiera ustawienia kolorów &#40;*ColorScheme*&#41;, typografii &#40;*Typography*&#41; i kształtów &#40;*Shapes*&#41; zgodne z *Material Design 3*.)

[//]: # (    - W efekcie wszystko, co wrzucisz wewnątrz bloku `FirstJetPackTheme { … }`, będzie renderowane w ramach Twojej własnej templatki kolorystycznej)

[//]: # (        &#40;np. jasne/ciemne motywy, wartości domyślne kolorów primary/secondary itd.&#41;.)

[//]: # (- `Scaffold&#40;modifier = Modifier.fillMaxSize&#40;&#41;&#41; { innerPadding -> … }`)

[//]: # (    - *composable* z biblioteki *Material*, który realizuje tzw. „szkielet” &#40;layout&#41; aplikacji:)

[//]: # (    - `modifier` powoduje, że *Scaffold* zajmuje cały dostępny ekran &#40;.fillMaxSize&#40;&#41;&#41;.)

[//]: # ()
[//]: # ()
[//]: # ()
[//]: # ()
[//]: # (```kotlin)

[//]: # (@Composable)

[//]: # (fun Greeting&#40;name: String, modifier: Modifier = Modifier&#41; {)

[//]: # (    Text&#40;)

[//]: # (        text = "Hello $name!",)

[//]: # (        modifier = modifier)

[//]: # (    &#41;)

[//]: # (})

[//]: # (```)

[//]: # ()
[//]: # (`@Composable`)

[//]: # (- To kluczowa adnotacja w *Jetpack Compose*. Oznacza, że dana funkcja może emitować elementy interfejsu użytkownika.)

[//]: # (    - „Emitować elementy UI” = „wytwarzać je dynamicznie w bardzo deklaratywny sposób, zamiast ręcznie tworzyć widoki w XML lub w kodzie imperatywnym”.)

[//]: # (    - Każda funkcja @Composable po prostu mówi: „Compose, ja chcę, żebyś umieścił tutaj ten komponent &#40;np. tekst, przycisk, kolumnę…&#41;”. Compose odbiera to polecenie i buduje wewnętrzne drzewo widoków.)

[//]: # (- Każdy *composable* może być traktowany jako „widget”/„widok”, który zostanie przetworzony podczas budowania drzewa UI.)

[//]: # ()
[//]: # (Parametry funkcji)

[//]: # (- `name: String` – zwykły parametr, którego używasz do dynamicznego wyświetlania treści &#40;w tym wypadku wstawiasz sformatowany tekst "Hello $name!"&#41;.)

[//]: # (- `modifier: Modifier = Modifier` – standardowy sposób przekazywania modyfikatorów &#40;marginesów, wypełnień, tła, szerokości/ wysokości itd.&#41;. Domyślnie to po prostu pusty &#40;Modifier&#41;.)

[//]: # (- Dzięki takiemu podejściu można w razie potrzeby „owinąć” Greeting w jakieś dodatkowe ustawienia layoutowe, np. padding, albo clickable, albo background – bez konieczności modyfikowania środka composable.)

[//]: # (- Text&#40;text = "Hello $name!", modifier = modifier&#41;)

[//]: # (- Text to podstawowy composable do wyświetlania ciągu znaków.)

[//]: # ()
[//]: # (Przekazujesz mu sformatowaną wartość "Hello $name!".)

[//]: # ()
[//]: # (Dodatkowo stosujesz przekazany wcześniej modifier, więc akurat w tym miejscu trafia Modifier.padding&#40;innerPadding&#41; &#40;podany z Scaffold&#41;, czyli twój tekst zostanie odsunięty o tyle pikseli, ile Scaffol­d uznał za słuszne &#40;przykładowo uwzględniając wysokość topBar’a, gdybyś go miał&#41;.)

[//]: # ()
[//]: # ()
[//]: # ()
[//]: # ()
[//]: # ()
[//]: # ()
[//]: # ()
