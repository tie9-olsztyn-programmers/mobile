---
title: CheckBox, Switch, RadioButton
---


# Aplikacja *UstawieniaU≈ºytkownika* CheckBox, Switch, RadioButton
- utw√≥rz projekt *Empty View*
- istniejƒÖce *Composable* `Greeting` zamie≈Ñ na `UserSettings`
- skasuj parameter `name`, kt√≥ry wystƒôpowa≈Ç w `Greeting`

```kotlin
@Composable
fun UserSettings( modifier: Modifier = Modifier) {

}

@Preview(showBackground = true)
@Composable
fun GreetingPreview() {
    CheckSwitchRadioJCTheme {
        UserSettings()
    }
}
```

Aplikacja bƒôdzie zawiera≈Ça:
- `Switch` w≈ÇƒÖczanie trybu powiadomie≈Ñ
- `Checkbox`y wyb√≥r zainteresowa≈Ñ
- `RadioButtony` ‚Äì wyb√≥r motywu aplikacji (*Light*, *Dark*, *System*)

| Komponent       | Opis                                                                                        | Kiedy u≈ºywaƒá?                                                                                              | Przyk≈Çad u≈ºycia w aplikacji                                              | Wizualizacja                         |
| --------------- | ------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------ | ------------------------------------ |
| **Checkbox**    | Pole wyboru pozwalajƒÖce zaznaczyƒá **dowolnƒÖ liczbƒô opcji**. Ka≈ºdy checkbox jest niezale≈ºny. | - Lista zainteresowa≈Ñ<br/>- Lista zada≈Ñ ‚Äûto-do‚Äù<br/>- Filtry (np. ‚Äûpoka≈º tylko dania wege i ostre‚Äù)        | Ucze≈Ñ mo≈ºe wybraƒá kilka zajƒôƒá dodatkowych: programowanie, muzyka, sport. | ‚òë Programowanie<br/>‚¨ú Muzyka         |
| **Switch**      | Prze≈ÇƒÖcznik ON/OFF. Zawsze ma tylko dwa stany: aktywny / nieaktywny.                        | - W≈ÇƒÖczanie powiadomie≈Ñ<br/>- Tryb ciemny<br/>- W≈ÇƒÖczenie modu≈Çu GPS                                       | Przycisk ‚ÄûW≈ÇƒÖcz powiadomienia‚Äù w ustawieniach aplikacji.                 | üü©‚óâ ON / ‚ö™ OFF                       |
| **RadioButton** | Element wyboru **jednej opcji z wielu**. Ka≈ºdy RadioButton nale≈ºy do jednej grupy.          | - Wyb√≥r motywu aplikacji (jasny / ciemny / systemowy)<br/>- Wyb√≥r p≈Çatno≈õci<br/>- Jedna odpowied≈∫ w quizie | U≈ºytkownik wybiera jeden motyw aplikacji.                                | ‚óâ Jasny<br/>‚óã Ciemny<br/>‚óã Systemowy |

Podstawowa struktura:
```kotlin
Checkbox(checked = value, onCheckedChange = { value = it })
Switch(checked = on, onCheckedChange = { on = it })
RadioButton(selected = isSelected, onClick = { isSelected = true })


```

## Dodajemy `Checkbox`y

### Pierwszy `Checkbox` z napisem "Programowaniem"
```kotlin
 Column() {
        Text(text="Zainteresowania")

            Checkbox(
                checked = true,
                onCheckedChange = { })
            Text(text="Programowanie")
}
```
Napis "Programowanie znalaz≈Ç siƒô pod `Checkbox`em.
By≈Çoby lepiej, gdyby znajdowa≈Ç siƒô po prawej stronie tego napisu.
Dlatego te≈º dodamy `Row`.
```kotlin
Column() {
        Text(text="Zainteresowania")

        Row(verticalAlignment = Alignment.CenterVertically){
            Checkbox(
                checked = true,
                onCheckedChange = { })
            Text(text="Programowanie")
        }
}
```
:::tip `Row` *vertical* a jednak *horizontal*
- `Row` elementy sƒÖ ustawiane horyzontalnie (w poziomie) ‚Äì od lewej do prawej:
    - o≈õ g≈Ç√≥wna (*main axis*) jest pozioma
    - o≈õ pomocnicza (*cross axis*) jest pionowa (*vertical*)
- `verticalAlignment:
    - oznacza jak elementy majƒÖ byƒá wyr√≥wnane w pionie wzglƒôdem siebie
    - w `Row` nie ma nic wsp√≥lnego z uk≈Çadem lewo‚Äìprawo
    - to tylko pionowe wyr√≥wnanie element√≥w, kt√≥re i tak sƒÖ ju≈º obok siebie.

:::

### Logika dzia≈Çania naszego `Checkbox`a
- potrzebujemy zmiennej, kt√≥ra bƒôdzie przechowywaƒá informacje o tym, czy checkbox jest zaznaczony
- potrzebujemy mechanizmu, kt√≥ry umo≈ºliwi zapamiƒôtanie tej zmiennej

```kotlin
 var isProgrammingChecked by remember { mutableStateOf(false) }

    Column() {
        Text(text="Zainteresowania")

        Row(verticalAlignment = Alignment.CenterVertically){
            Checkbox(
                checked = isProgrammingChecked,
                onCheckedChange = { newValue ->
                    isProgrammingChecked = newValue
                    Log.i("check", "$isProgrammingChecked")
                })
            Text(text="Programowanie")
        }

    }
```
**Wyja≈õnienie**
` var isProgrammingChecked by remember { mutableStateOf(false) }` znaczy:
    - stworzy zmiennƒÖ, kt√≥ra bƒôdzie pamiƒôtaƒá, czy u≈ºytkownik zaznaczy≈Ç `checkbox` "Programowanie",
    - na poczƒÖtku niech bƒôdzie odznaczona (`false`).
    - nawet jak ekran siƒô prze≈Çaduje (np. obr√≥cisz telefon), to ta informacja ma nie zniknƒÖƒá.
- `remember`
    - ‚ÄûZapamiƒôtaj to dla mnie‚Äù.
    - Gdyby go nie by≈Ço:
        - za ka≈ºdym razem, gdy ekran siƒô od≈õwie≈ºy (np. obr√≥cisz telefon albo Compose co≈õ przerysuje),
        - stan wr√≥ci≈Çby do poczƒÖtkowego i checkbox ‚Äûzapomnia≈Çby‚Äù, ≈ºe by≈Ç zaznaczony.
- `mutableStateOf`
    - tworzy specjalny obiekt, kt√≥ry ‚Äûpilnuje‚Äù warto≈õci `false` (czyli checkbox odznaczony)
    - gdy u≈ºytkownik kliknie `checkbox`, warto≈õƒá zmieni siƒô na `true`
    - a Compose automatycznie przerysuje ekran
    - to specjalny obiekt, kt√≥ry potrafi powiedzieƒá Compose‚Äôowi:
        - ‚ÄûHej! Ja siƒô w≈Ça≈õnie zmieni≈Çem! Proszƒô przerysuj ekran!‚Äù

## Dodajemy kolejne dwa `Checkbox`y - "Sport" i "Muzyka"
- zwr√≥ƒá uwagƒô, ≈ºe `Column` dosta≈Ç `modifier`

```kotlin
@Composable
fun UserSettings( modifier: Modifier = Modifier) {

    var isProgrammingChecked by remember { mutableStateOf(false) }
    var isSportChecked by remember { mutableStateOf(false) }
    var isMusicChecked by remember { mutableStateOf(false) }

    Column( modifier = modifier) {
        Text(text="Zainteresowania",
            fontSize = 20.sp,
            modifier = Modifier.padding(top=24.dp, bottom = 10.dp)
        )

        Row(verticalAlignment = Alignment.CenterVertically){
            Checkbox(
                checked = isProgrammingChecked,
                onCheckedChange = { newValue ->
                    isProgrammingChecked = newValue
                })
            Text(text="Programowanie")
        }

        Row(verticalAlignment = Alignment.CenterVertically){
            Checkbox(
                checked = isSportChecked,
                onCheckedChange = { newValue ->
                    isSportChecked = newValue
                })
            Text(text="Sport")
        }

        Row(verticalAlignment = Alignment.CenterVertically){
            Checkbox(
                checked = isMusicChecked,
                onCheckedChange = { newValue ->
                    isMusicChecked = newValue
                })
            Text(text="Muzyka")
        }
    }
}
```

## Dynamiczne tworzenie `Checkbox`√≥w
- mamy kilka `Checkbox`√≥w, wiƒôc nasza funkcja `Composable` zaczyna byƒá nieczytelna
- bƒôdziemy dynamicznie generowaƒá `Checkbox`y



### `data class` - model dla zainteresowa≈Ñ

`Interest.kt`
```

data class Interest (val name: string, var checked: Boolean)

```

### Utworzenie listy obiekt√≥w `Interest`
Zamiast oddzielnych zmiennych w naszej funkcji `Composable` utworzymy listƒô obiekt√≥w `Interest`:
```kotlin
@Composable
fun UserSettings( modifier: Modifier = Modifier) {
    // var isProgrammingChecked by remember { mutableStateOf(false) }
    // var isSportChecked by remember { mutableStateOf(false) }
    // var isMusicChecked by remember { mutableStateOf(false) }

    val interests = remember {
    mutableStateListOf(
        Interest("Programowanie", false),
        Interest("Muzyka", false),
        Interest("Sport", false)
    )
}
```
### Dynamiczne generowanie `Checkbox`√≥w
```kotlin
@Composable
fun UserSettings( modifier: Modifier = Modifier) {
//...

 Column( modifier = modifier) {
        Text(text="Zainteresowania",
            fontSize = 20.sp,
            modifier = Modifier.padding(top=24.dp, bottom = 10.dp)
        )

        interests.forEachIndexed { index, interest ->
            Row(verticalAlignment = Alignment.CenterVertically){
                Checkbox(
                    checked = interest.checked,
                    onCheckedChange = {

                        // copy stworzy nowy obiekt
                        // wiƒôc zmieni siƒô lista
                        // wiƒôc UI zostanie poinformowane o zmiania
                        interests[index] = interest.copy(checked = it)

                        /*to list obiekt√≥w jest reactywna (informuje UI o zmianach
                        * sam obiekt i jego w≈Ça≈õciwo≈õci nie sƒÖ reaktywne, wiƒôc
                        * nie informujƒÖ UI o swoich zmianach
                        * */
                       // interest.checked = it
                    }
                )
                Text(text=interest.name)
            }
        }
    }
```

## Dodajemy `Switch`
Musimy:
- dodaƒá zmiennƒÖ przechowujƒÖcƒÖ stan `Switch`a
- dodaƒá funkcjƒô tworzƒÖcƒÖ `Switch`
```kotlin
@Composable
fun UserSettings( modifier: Modifier = Modifier) {
//...

 var notificationsEnabled by remember { mutableStateOf(false) }

//...pod checkboxami

Row(modifier=Modifier
            .fillMaxWidth()
            .padding(horizontal = 20.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.End

        ) {
            Text("Powiadomienia")

            Spacer(modifier=Modifier.width(12.dp))

            Switch(
                modifier = Modifier.padding(20.dp),
                checked = notificationsEnabled,
                onCheckedChange = {
                    notificationsEnabled = it
                    println(notificationsEnabled)
                }
            )
        }
```
:::important Najwa≈ºniejsza zasada Compose (zapamiƒôtaj na zawsze)
- Je≈õli co≈õ ma siƒô zmieniaƒá i ekran ma to zobaczyƒá, musi byƒá w `remember { mutableStateOf(...) }`.
- Bez tego Compose jest ≈õlepy na zmiany i nic siƒô nie aktualizuje.

:::

:::tip syntaktyka z `by` *property delegation*
"Hej, ta zmienna ma nie trzymaƒá bezpo≈õrednio warto≈õci false,
tylko ma korzystaƒá z innego obiektu (tutaj `MutableState`),
a Ty (Kotlin) zajmij siƒô za mnie automatycznym wywo≈Çywaniem `.getValue()` i `.setValue()`"

Kotlin zamienia:
`var notificationsEnabled by remember { mutableStateOf(false) }`

na

```kotlin
private val notificationsEnabled$delegate = remember { mutableStateOf(false) }

var notificationsEnabled: Boolean
    get() = notificationsEnabled$delegate.value          // automatyczne .value przy odczycie
    set(value) = notificationsEnabled$delegate.value = value  // automatyczne .value przy zapisie
```

:::



## Dodajemy `RadioButton`y - motyw aplikacji
Potrzebujemy:
- zmiennej, kt√≥ra przechowa informacjƒô o tym, kt√≥ry `RadioButton` zosta≈Ç wybrany
- funkcji, kt√≥ra tworzy `RadioButton`y

```kotlin
@Composable
fun UserSettings( modifier: Modifier = Modifier) {
//...
    var notificationsEnabled by remember { mutableStateOf(false) }

    var selectedTheme by remember { mutableStateOf("light") }

// ... pod switchem
 Row(modifier = Modifier.padding(10.dp),
            verticalAlignment = Alignment.CenterVertically){

            RadioButton(
                selected = selectedTheme == "light",
                onClick = {selectedTheme = "light"}
            )
            Text(text="Jasny")
        }

        Row(modifier = Modifier.padding(10.dp),
            verticalAlignment = Alignment.CenterVertically){
            RadioButton(
                selected = selectedTheme == "dark",
                onClick = {selectedTheme = "dark"}
            )
            Text(text="Ciemny")
        }

        Row(modifier = Modifier.padding(10.dp),
            verticalAlignment = Alignment.CenterVertically
            ){
            RadioButton(
                    selected= selectedTheme == "system",
                    onClick = {selectedTheme = "system"}
                    )
            Text(text="Systemowy")
        }
        Text(text="Tw√≥j wyb√≥r: $selectedTheme",
             modifier=Modifier.padding(10.dp)
            )
    }
```

## Dodajemy przycisk podsumowania
- potrzebujemy przycisku, po naci≈õniƒôciu kt√≥rego na dole ekranu pojawi siƒô podsumowanie formularza
- wiƒôc potrzebujemy te≈º pola do wy≈õwietlenia podsumowania
- czyli potrzebujemy te≈º zmiennej, kt√≥ra przechowa informacje z formularza

```kotlin
@Composable
fun UserSettings( modifier: Modifier = Modifier) {
//...
    var summary by remember { mutableStateOf("") }



//...
  Text(text="Tw√≥j wyb√≥r: $selectedTheme",
             modifier=Modifier.padding(10.dp)
            )

// --------- podsumowanie ---------------------


        Spacer(modifier= Modifier.size(20.dp))
        Button(modifier = Modifier.padding(10.dp),
            onClick = {

                summary = "Motyw $selectedTheme, powiadomienia $notificationsEnabled" +
                        ", zainteresowania ${
                            interests
                                .filter { it.checked }
                                .joinToString { it.name  }
                        }"
            }){
            Text(text="Podsumowanie")
        }
        Text(modifier = Modifier.padding(vertical = 12.dp, horizontal = 5.dp ),
            text = "P o d s u m o w a n i e",
            fontSize = 30.sp,
            fontWeight = FontWeight.Bold
            )
        Text(summary)

```
:::danger Podstawowy problem
Nasza aplikacja zawiera siƒô w jednym pliku.

- przestaje byƒá czytelna
- staje siƒô trudna do rozbudowy i testowania
- ... i w og√≥le jest niepoprawna

:::

Zanim przejdziemy do podzia≈Çu naszej aplikacji na komponenty *Compose*,
musimy nauczyc siƒô przekazywaƒá dane miƒôdzy komponentami.











